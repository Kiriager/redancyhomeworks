import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
//import { fetchCount } from './counterAPI';

export interface NotesState {
  notesList: NoteData[],
  categoriesList: Category[],
  showArchiveNotes: boolean
//  tableArchiveStatus: "arhived" | "active",
//   status: 'idle' | 'loading' | 'failed';
}

export interface NoteData {
  id: number,
  name: string,
  createDate: Date,
  archivedStatus: boolean,
  content: string,
  category: Category,
  editStatus: boolean
}

export interface Category {
  categoryName: string,
  categoryIcon: string
}

export interface CategoryStats {
  category: Category, 
  active: number, 
  archived: number
}

const initialState: NotesState = {
  notesList: [
    {id: 1, name: "task1", createDate: new Date(), archivedStatus: false, 
        content: "do task 1 in 19-11-2022", 
        category: {categoryName: "Task", categoryIcon: "fa-solid fa-thumbtack"}, editStatus: false},
    {id: 2, name: "task2", createDate: new Date(), archivedStatus: false, 
        content: "do task 2 in 19 11 2022 and in 16-10-2022", 
        category: {categoryName: "Task", categoryIcon: "fa-solid fa-thumbtack"}, editStatus: false},
    {id: 3, name: "task3", createDate: new Date(), archivedStatus: false, 
        content: "do task 3 in 19.11.2022 and in 16/10/2022", 
        category: {categoryName: "Task", categoryIcon: "fa-solid fa-thumbtack"}, editStatus: false},
    {id: 4, name: "task4", createDate: new Date(), archivedStatus: true, 
        content: "Just nice thought", 
        category: {categoryName: "Random Thought", categoryIcon: "fa-solid fa-lightbulb"}, editStatus: false}
  ],
  categoriesList:  [
    {categoryName: "Task", categoryIcon: "fa-solid fa-thumbtack"}, 
    {categoryName: "Idea", categoryIcon: "fa-solid fa-gears"}, 
    {categoryName: "Random Thought", categoryIcon: "fa-solid fa-lightbulb"}
  ],
  showArchiveNotes: false
}



export const noteSlice = createSlice({
  name: 'notes',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    add: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      //state.value += 1;
    },
    edit: (state) => {
      
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    remove: (state) => {
      
    },
    archive: (state, action: PayloadAction<number>) => {
      alert(action.payload)
      console.log(action.payload);
      let note = state.notesList.find((note) => {return note.id == action.payload})
      if (typeof(note) != 'undefined') {
        note.archivedStatus = !note.archivedStatus
      }
    },
    unarchive: (state) => {
      
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  
});

export const { add, edit, archive, unarchive, remove } = noteSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
//export const selectNote = (state: RootState) => state.note.data;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default noteSlice.reducer;
